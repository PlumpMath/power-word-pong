<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_fireball</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>team = 1

acceleration = 1

sprite_ball[0] = s_iceball;
sprite_ball[1] = s_fireball;

sfx_hit[0] = snd_ice_attack;
sfx_hit[1] = snd_fire_attack;

can_score = true;
//can_transform = true;
collision_last = noone;

h_speed = 0
v_speed = 0
max_speed = 6

rotation_frequency = 4;
rotation_direction = 1;
rotation_counter = rotation_frequency

image_speed = 4/room_speed

var initial = irandom(1);
sprite_index = sprite_ball[initial];

h_target_speed = max_speed * (1-2*initial); //0-&gt;1, 1-&gt;-1
v_target_speed = max_speed;

playing = false;
alarm[0] = room_speed * 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>playing = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (playing==false) { exit; }

collision_other = instance_place(x + h_speed, y + v_speed, o_wizard)

// Rebotes.
if (x&lt;global.boundaries[3])
{
    h_target_speed = max_speed;
    if (can_score &amp;&amp; sprite_index == sprite_ball[1])
    {
        can_score = false;
        f_score(1);
        f_sfx(snd_fire_score);
    }
}
else if (x&gt;global.boundaries[1])
{
    h_target_speed = -max_speed;
    if (can_score &amp;&amp; sprite_index == sprite_ball[0])
    {
        can_score = false;
        f_score(0);
        f_sfx(snd_ice_score);
    }
}
if (y&lt;global.boundaries[0])
{
    v_target_speed = max_speed;
}
else if (y&gt;global.boundaries[2])
{
    v_target_speed = -max_speed;
}

// Cuando rebote contra un jugador, convertirse o cambiar de direcci√≥n vertical.
if (collision_other != noone &amp;&amp; collision_other != collision_last)
{
    h_target_speed = max_speed * (1-2*collision_other.team); //0-&gt;1, 1-&gt; -1
    if (collision_other.team == 0 &amp;&amp; sprite_index == sprite_ball[0] || collision_other.team == 1 &amp;&amp; sprite_index == sprite_ball[1])
    {
        v_target_speed = -v_target_speed;
    }
    sprite_index = sprite_ball[collision_other.team];
    f_sfx(sfx_hit[collision_other.team]);
    
    collision_last = collision_other;
}
else if (collision_other == noone)
{
    collision_last = noone;
}

// Puede volver a puntuar una vez salga de la zona de puntajes.
if (x&gt;global.boundaries[3] &amp;&amp; x&lt;global.boundaries[1])
{
    can_score = true;
}

h_speed = f_diff(h_speed, acceleration, h_target_speed);
v_speed = f_diff(v_speed, acceleration, v_target_speed);

x += h_speed
y += v_speed

if (h_speed!=0) { image_xscale = sign(-h_speed); }

rotation_counter -= 1;
if (rotation_counter &lt;= 0)
{
    image_angle += 90 * sign(-h_speed); //rotation_direction;
    rotation_counter = rotation_frequency;
}

depth = -y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
